# Исследование оптимизаций поиска значений в хеш-таблице с закрытой адресацией.
## Введение
Рассмотрим следующую задачу:

*"Дан художественный текст на английском языке. Требуется составить множество слов текста, то есть структуру, хранящую все его слова и позволяющую как можно быстрее определять принадлежность некоторого слова к нему."*

Задача может быть решена с использованием хеш-таблицы c закрытой адресацией (описание алгоритма на [AlgoList](https://www.algolist.net/Data_structures/Hash_table)).

Введём следующие определения:
 - **ключ** (**элемент**) - идентификатор элемента, хранящегося в структуре. В случае рассматриваемой задачи это слово из текста.
 - **хеш-функция** - функция, сопоставляющая ключам некоторые натуральные числа. Числа, сопоставляемые одинаковым ключам должны быть равны.
 - **хеш** - значение хеш-функции.
 - **список** (**bucket**) - множество элементов, в которое можно добавлять ключи и проверять, находятся ли они в нём. Соответствует структуре данных "связный список".
 - **хеш-таблица** (**таблица**) - множество списков, в каждом из которых всем ключам соответствуют одинаковые по модулю количества списков в таблице хеши.

**Проверка принадлежности** ключей к хеш-таблице происходит по следующей последовательности действий:
 1. Пусть требуется проверить ключ $x$ на принадлежность к таблице. Посчитаем хеш элемента $h(x)$, где $h$ - хеш-функция.
 2. Рассмотрим $h(x) \text{mod} N$ - й список таблицы, где $N$ - количество списков в таблице. Если $x$ принадлежит списку, то $x$ принадлежит таблице. Иначе $x$ не принадлежит таблице.

| ![article_assets/table_search.png](article_assets/table_search.png) |
| --- |
| *Фигура 1. Иллюстрация к проверке принадлежности ключа к таблице. Зелёными ячейками обозначены индексы списков внутри таблицы. Синими клетками обозначены элементы самих списков. Символом '%' обозначено взятие числа по модулю. Остальные обозначения совпадают с обозначениями, введёнными в описании алгоритма.* |

**Добавление** ключа в таблицу происходит по следующей последовательности действий:
 1. Если ключ $x$ уже принадлежит таблице, ничего не делать.
 2. Иначе добавить $x$ в $h(x) \text{mod} N$ - й список таблицы, где $N$ - количество списков в таблице, $h$ - хеш-функция.

| ![article_assets/table_insert.png](article_assets/table_insert.png) |
| --- |
| *Фигура 2. Иллюстрация к добавлению ключа к таблице. Зелёными ячейками обозначены индексы списков внутри таблицы. Синими клетками обозначены элементы самих списков. Символом '%' обозначено взятие числа по модулю. Остальные обозначения совпадают с обозначениями, введёнными в описании алгоритма.* |

Целью данной работы является измерение коэффициента ускорения при использовании различных методов оптимизации проверки принадлежности элементов к таблице.

Исследуемые оптимизации:
 - оптимизация при помощи SIMD (Single Instruction Multiple Data) набора инструкций ассемблера,
 - Оптимизация переписыванием части кода на ассемблер.

## Методы
В качестве объекта оптимизации была взята программа, выполняющая следующие действия:
 1. заполнить хеш-таблицу с хеш-функцией [MurmurHash64](https://en.wikipedia.org/wiki/MurmurHash) ключами, являющимися словами произведения Вильяма Шекспира ["The Comedy of Errors"](assets/comedy_of_errors.txt) в нижнем регистре в кодировке utf-8,
 2. 2048 раз выполнить поиск всех слов произведения в таблице (т.е. 2048 раз запустить цикл по всем словам произведения, для каждого из которых выполняется проверка на принадлежность к таблице).
 3. Повторить предыдущее действие 32 раза, записывая время исполнения каждого повтора в таблицу.
 4. Записать таблицу измерений в файл в формате `csv`.

Для искусственного увеличения времени поиска в таблице с учётом малого набора данных количество списков в хеш-таблице было уменьшено до 17.

Далее на программе были выполнены исследуемые оптимизации. Перед применением каждой оптимизации программа анализировалась valgrind с модулем callgrind для определения функции программы, оптимизация которой даст наибольший прирост производительности.

Текст подавался программе в виде бинарного файла, разбитого на области по 32 байта, каждая из которых хранила по одному слову текста в кодировке utf-8. Пустые байты были заполнены нулями, слова длинны более 32 игнорировались (в используемом тексте таких слов не было).

Условия запуска:
 - Ноутбук Lenovo Legion 15ARH05H, подключенный к снабжающей его сети электропитания
```
Processor	AMD Ryzen 5 4600H with Radeon Graphics            3.00 GHz
Installed RAM	16.0 GB (15.9 GB usable)
Product ID	00325-81942-83222-AAOEM
System type	64-bit operating system, x64-based processor
```
 - ОС: Windows 10 Home 22H2 (Build 19045.2846).
 - WSL: Ubuntu 20.04.5 LTS

## Результаты
Результат работы не оптимизированной программы можно найти в файле [results/bmark_0.csv].(results/bmark_0.csv).

Среднее время обработки 2-го действия программы (поиска слов в тексте 2048 раз) составило $4.02\pm0.05$ секунд.

Так как профайлер значительно замедляет программу, число повторов тестов было снижено с 2048 до 1.

Результат профилизации программы на данном этапе приведён в листинге 1.
```log
--------------------------------------------------------------------------------
Ir           file:function
--------------------------------------------------------------------------------
124,304,458  /build/glibc-SzIz7B/glibc-2.31/string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strcmp_avx2 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
 69,552,010  src/hash/hash_table.hpp:HashTable_find_value(HashTable const*, unsigned long long, char const*, int (*)(char const*, char const*)) [/root/projects/hash_functions/build/hash_testcase_v0.1_dev_linux.out]
  9,931,680  ./src/hash/hash_functions.cpp:murmur_hash(void const*, void const*) [/root/projects/hash_functions/build/hash_testcase_v0.1_dev_linux.out]
  2,759,120  src/main.cpp:main [/root/projects/hash_functions/build/hash_testcase_v0.1_dev_linux.out]
```
*Листинг 1. Вырезка из вывода valgrind, обработанного callgrind_annotate. Приведённые функции: `__strcmp_avx2` - функция `strcmp` из стандартного модуля `string.h`, `HashTable_find_value` - функция поиска ключа в хеш-таблице, `murmur_hash` - хеш-функция.*

Большую часть времени программа тратит на исполнение функции `strcmp`, которая чаще всего вызывается из `HashTable_find_value`.

Можно заметить, что использование strcmp в данной задаче не оптимально, так как к сравнению строк в данной задаче могут быть применены оптимизации, локальные для задачи, которых в библиотечной функции по определению быть не может. К примеру, учитывая формат входных данных, функции проверки строк в данной задаче не обязательно учитывать выравнивание строк перед их загрузкой в регистр, что библиотечная функция по умолчанию делает. Также, учитывая фиксированный размер строк, функция может один раз загрузить слово в 256-битный векторный целочисленный регистр и сравнить его с другим аналогичным регистром. Таким образом, функция `strcmp` может быть заменена гораздо более быстрым intrinsic-эквивалентом `_mm256_testc_epi8`.

После данной оптимизации среднее время обработки 2-го действия программы составило $1.37\pm0.01$ секунд.

Результат профилизации на данном этапе приведён в листинге 2.
```log
--------------------------------------------------------------------------------
Ir          file:function
--------------------------------------------------------------------------------
40,431,242  src/hash/hash_table.hpp:HashTable_find_value(HashTable const*, unsigned long long, long long __vector(4), int (*)(long long __vector(4), long long __vector(4))) [/root/projects/hash_functions/build/hash_testcase_v0.1_dev_linux.out]
 9,931,680  ./src/hash/hash_functions.cpp:murmur_hash(void const*, void const*) [/root/projects/hash_functions/build/hash_testcase_v0.1_dev_linux.out]
 2,575,198  src/main.cpp:main [/root/projects/hash_functions/build/hash_testcase_v0.1_dev_linux.out]
```
*Листинг 2. Вырезка из вывода valgrind, обработанного callgrind_annotate. Приведённые функции: `HashTable_find_value` - функция поиска ключа в хеш-таблице, `murmur_hash` - хеш-функция.*

Перепишем функцию `HashTable_find_value` на assembly.

Переписанную функцию можно найти в файле [src/hash/hash_table_search.s](src/hash/hash_table_search.s).

После переписи среднее время обработки 2048 тестов составило $1.36\pm0.01$ секунд.

Абсолютный коэффициент ускорения после первой оптимизации составил $2.93\pm0.05$ раза относительно базовой реализации, а после второй - $2.96\pm0.06$ раза.

Относительный коэффициент ускорения после второй оптимизации составил $1.01\pm0.01$ раза относительно версии с одной оптимизацией.

Обработка исходных результатов экспериментов была проведена в файле [results/bmark_combined.xlsx](results/bmark_combined.xlsx).

## Выводы и обсуждение
Как было показано, наиболее эффективной оптимизацией была оптимизация SIMD-ами. Перепись кода на ассемблер дало лишь незначительное ускорение.

Из этого следует, что оптимизации использованием SIMD эффективны, так как их внедрение требует изменения логики работы программы, чего компилятор не может сделать, гарантируя при этом сохранение работоспособности программы. Перепись же кода на ассемблер без изменения общей логики программы гораздо менее эффективно, так как компиляторы уже применяют те оптимизации, которые человеку сложно заметить и ещё сложнее улучшить. Тем не менее можно перебирать различные компиляторы и смотреть, какой из них эффективнее напишет конкретный сегмент кода. К примеру, в данной работе основная часть кода была скомпилирована `gcc`, в то врем как за основу ассемблерной переписи был взят код, сгенерированный `CLang`, который, как было показано, оптимизировал функцию немного лучше.